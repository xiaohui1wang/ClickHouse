diff --git a/src/nfagraph/ng_violet.cpp b/src/nfagraph/ng_violet.cpp
index ba6b350..a51212d 100644
--- a/src/nfagraph/ng_violet.cpp
+++ b/src/nfagraph/ng_violet.cpp
@@ -375,7 +375,7 @@ void getSimpleRoseLiterals(const NGHolder &g, bool seeking_anchored,
 
         DEBUG_PRINTF("candidate is a candidate\n");
         scores[v] = score;
-        lit_info[v] = make_unique<VertLitInfo>(v, s, anchored);
+        lit_info[v] = std::make_unique<VertLitInfo>(v, s, anchored);
     }
 
     /* try to filter out cases where appending some characters produces worse
@@ -531,7 +531,7 @@ void getRegionRoseLiterals(const NGHolder &g, bool seeking_anchored,
         }
 
         DEBUG_PRINTF("candidate is a candidate\n");
-        lits->push_back(make_unique<VertLitInfo>(vv, s, anchored));
+        lits->push_back(std::make_unique<VertLitInfo>(vv, s, anchored));
     }
 }
 
@@ -945,7 +945,7 @@ unique_ptr<VertLitInfo> findSimplePrefixSplit(const NGHolder &g,
         sanitizeAndCompressAndScore(best_lit_set);
     }
 
-    return ue2::make_unique<VertLitInfo>(best_v, best_lit_set, anchored, true);
+    return std::make_unique<VertLitInfo>(best_v, best_lit_set, anchored, true);
 }
 
 static
@@ -1848,7 +1848,7 @@ static
 unique_ptr<NGHolder> make_chain(u32 count) {
     assert(count);
 
-    auto rv = make_unique<NGHolder>(NFA_INFIX);
+    auto rv = std::make_unique<NGHolder>(NFA_INFIX);
 
     NGHolder &h = *rv;
 
diff --git a/src/rose/rose_build_program.cpp b/src/rose/rose_build_program.cpp
index 96c95db..7d1d7ec 100644
--- a/src/rose/rose_build_program.cpp
+++ b/src/rose/rose_build_program.cpp
@@ -95,7 +95,7 @@ OffsetMap makeOffsetMap(const RoseProgram &program, u32 *total_len) {
 }
 
 RoseProgram::RoseProgram() {
-    prog.push_back(make_unique<RoseInstrEnd>());
+    prog.push_back(std::make_unique<RoseInstrEnd>());
 }
 
 RoseProgram::~RoseProgram() = default;
@@ -297,28 +297,28 @@ void addEnginesEodProgram(u32 eodNfaIterOffset, RoseProgram &program) {
     }
 
     RoseProgram block;
-    block.add_before_end(make_unique<RoseInstrEnginesEod>(eodNfaIterOffset));
+    block.add_before_end(std::make_unique<RoseInstrEnginesEod>(eodNfaIterOffset));
     program.add_block(move(block));
 }
 
 void addSuffixesEodProgram(RoseProgram &program) {
     RoseProgram block;
-    block.add_before_end(make_unique<RoseInstrSuffixesEod>());
+    block.add_before_end(std::make_unique<RoseInstrSuffixesEod>());
     program.add_block(move(block));
 }
 
 void addMatcherEodProgram(RoseProgram &program) {
     RoseProgram block;
-    block.add_before_end(make_unique<RoseInstrMatcherEod>());
+    block.add_before_end(std::make_unique<RoseInstrMatcherEod>());
     program.add_block(move(block));
 }
 
 void addFlushCombinationProgram(RoseProgram &program) {
-    program.add_before_end(make_unique<RoseInstrFlushCombination>());
+    program.add_before_end(std::make_unique<RoseInstrFlushCombination>());
 }
 
 void addLastFlushCombinationProgram(RoseProgram &program) {
-    program.add_before_end(make_unique<RoseInstrLastFlushCombination>());
+    program.add_before_end(std::make_unique<RoseInstrLastFlushCombination>());
 }
 
 static
@@ -342,11 +342,11 @@ void makeRoleCheckLeftfix(const RoseBuildImpl &build,
 
     unique_ptr<RoseInstruction> ri;
     if (is_prefix) {
-        ri = make_unique<RoseInstrCheckPrefix>(lni.queue, build.g[v].left.lag,
+        ri = std::make_unique<RoseInstrCheckPrefix>(lni.queue, build.g[v].left.lag,
                                                build.g[v].left.leftfix_report,
                                                end_inst);
     } else {
-        ri = make_unique<RoseInstrCheckInfix>(lni.queue, build.g[v].left.lag,
+        ri = std::make_unique<RoseInstrCheckInfix>(lni.queue, build.g[v].left.lag,
                                               build.g[v].left.leftfix_report,
                                               end_inst);
     }
@@ -384,7 +384,7 @@ void makeAnchoredLiteralDelay(const RoseBuildImpl &build,
     u32 anch_id = prog_build.anchored_programs.at(lit_id);
 
     const auto *end_inst = program.end_instruction();
-    auto ri = make_unique<RoseInstrAnchoredDelay>(groups, anch_id, end_inst);
+    auto ri = std::make_unique<RoseInstrAnchoredDelay>(groups, anch_id, end_inst);
     program.add_before_end(move(ri));
 }
 
@@ -393,7 +393,7 @@ void makeDedupe(const ReportManager &rm, const Report &report,
                 RoseProgram &program) {
     const auto *end_inst = program.end_instruction();
     auto ri =
-        make_unique<RoseInstrDedupe>(report.quashSom, rm.getDkey(report),
+        std::make_unique<RoseInstrDedupe>(report.quashSom, rm.getDkey(report),
                                      report.offsetAdjust, end_inst);
     program.add_before_end(move(ri));
 }
@@ -402,7 +402,7 @@ static
 void makeDedupeSom(const ReportManager &rm, const Report &report,
                    RoseProgram &program) {
     const auto *end_inst = program.end_instruction();
-    auto ri = make_unique<RoseInstrDedupeSom>(report.quashSom,
+    auto ri = std::make_unique<RoseInstrDedupeSom>(report.quashSom,
                                               rm.getDkey(report),
                                               report.offsetAdjust, end_inst);
     program.add_before_end(move(ri));
@@ -428,7 +428,7 @@ void makeCatchup(const ReportManager &rm, bool needs_catchup,
         return;
     }
 
-    program.add_before_end(make_unique<RoseInstrCatchUp>());
+    program.add_before_end(std::make_unique<RoseInstrCatchUp>());
 }
 
 static
@@ -511,12 +511,12 @@ void addLogicalSetRequired(const Report &report, ReportManager &rm,
         return;
     }
     // set matching status of current lkey
-    auto risl = make_unique<RoseInstrSetLogical>(report.lkey,
+    auto risl = std::make_unique<RoseInstrSetLogical>(report.lkey,
                                                  report.offsetAdjust);
     program.add_before_end(move(risl));
     // set current lkey's corresponding ckeys active, pending to check
     for (auto ckey : rm.getRelateCKeys(report.lkey)) {
-        auto risc = make_unique<RoseInstrSetCombination>(ckey);
+        auto risc = std::make_unique<RoseInstrSetCombination>(ckey);
         program.add_before_end(move(risc));
     }
 }
@@ -532,7 +532,7 @@ void makeReport(const RoseBuildImpl &build, const ReportID id,
 
     // Handle min/max offset checks.
     if (report.minOffset > 0 || report.maxOffset < MAX_OFFSET) {
-        auto ri = make_unique<RoseInstrCheckBounds>(report.minOffset,
+        auto ri = std::make_unique<RoseInstrCheckBounds>(report.minOffset,
                                                     report.maxOffset, end_inst);
         report_block.add_before_end(move(ri));
     }
@@ -540,7 +540,7 @@ void makeReport(const RoseBuildImpl &build, const ReportID id,
     // If this report has an exhaustion key, we can check it in the program
     // rather than waiting until we're in the callback adaptor.
     if (report.ekey != INVALID_EKEY) {
-        auto ri = make_unique<RoseInstrCheckExhausted>(report.ekey, end_inst);
+        auto ri = std::make_unique<RoseInstrCheckExhausted>(report.ekey, end_inst);
         report_block.add_before_end(move(ri));
     }
 
@@ -548,7 +548,7 @@ void makeReport(const RoseBuildImpl &build, const ReportID id,
     // calculated.
     if (isExternalSomReport(report) &&
         report.type != EXTERNAL_CALLBACK_SOM_PASS) {
-        auto ri = make_unique<RoseInstrSomFromReport>();
+        auto ri = std::make_unique<RoseInstrSomFromReport>();
         writeSomOperation(report, &ri->som);
         report_block.add_before_end(move(ri));
     }
@@ -556,13 +556,13 @@ void makeReport(const RoseBuildImpl &build, const ReportID id,
     // Min length constraint.
     if (report.minLength > 0) {
         assert(build.hasSom);
-        auto ri = make_unique<RoseInstrCheckMinLength>(
+        auto ri = std::make_unique<RoseInstrCheckMinLength>(
             report.offsetAdjust, report.minLength, end_inst);
         report_block.add_before_end(move(ri));
     }
 
     if (report.quashSom) {
-        report_block.add_before_end(make_unique<RoseInstrSomZero>());
+        report_block.add_before_end(std::make_unique<RoseInstrSomZero>());
     }
 
     switch (report.type) {
@@ -578,7 +578,7 @@ void makeReport(const RoseBuildImpl &build, const ReportID id,
                 if (needs_dedupe) {
                     if (!report.quiet) {
                         report_block.add_before_end(
-                            make_unique<RoseInstrDedupeAndReport>(
+                            std::make_unique<RoseInstrDedupeAndReport>(
                                 report.quashSom, build.rm.getDkey(report),
                                 report.onmatch, report.offsetAdjust, end_inst));
                     } else {
@@ -587,7 +587,7 @@ void makeReport(const RoseBuildImpl &build, const ReportID id,
                 } else {
                     if (!report.quiet) {
                         report_block.add_before_end(
-                            make_unique<RoseInstrReport>(
+                            std::make_unique<RoseInstrReport>(
                                 report.onmatch, report.offsetAdjust));
                     }
                 }
@@ -597,28 +597,28 @@ void makeReport(const RoseBuildImpl &build, const ReportID id,
                 }
                 if (!report.quiet) {
                     report_block.add_before_end(
-                        make_unique<RoseInstrReportExhaust>(
+                        std::make_unique<RoseInstrReportExhaust>(
                             report.onmatch, report.offsetAdjust, report.ekey));
                 } else {
                     report_block.add_before_end(
-                        make_unique<RoseInstrSetExhaust>(report.ekey));
+                        std::make_unique<RoseInstrSetExhaust>(report.ekey));
                 }
             }
         } else { // has_som
             makeDedupeSom(build.rm, report, report_block);
             if (report.ekey == INVALID_EKEY) {
                 if (!report.quiet) {
-                    report_block.add_before_end(make_unique<RoseInstrReportSom>(
+                    report_block.add_before_end(std::make_unique<RoseInstrReportSom>(
                         report.onmatch, report.offsetAdjust));
                 }
             } else {
                 if (!report.quiet) {
                     report_block.add_before_end(
-                        make_unique<RoseInstrReportSomExhaust>(
+                        std::make_unique<RoseInstrReportSomExhaust>(
                             report.onmatch, report.offsetAdjust, report.ekey));
                 } else {
                     report_block.add_before_end(
-                        make_unique<RoseInstrSetExhaust>(report.ekey));
+                        std::make_unique<RoseInstrSetExhaust>(report.ekey));
                 }
             }
         }
@@ -639,17 +639,17 @@ void makeReport(const RoseBuildImpl &build, const ReportID id,
             addFlushCombinationProgram(report_block);
         }
         if (has_som) {
-            auto ri = make_unique<RoseInstrReportSomAware>();
+            auto ri = std::make_unique<RoseInstrReportSomAware>();
             writeSomOperation(report, &ri->som);
             report_block.add_before_end(move(ri));
         } else {
-            auto ri = make_unique<RoseInstrReportSomInt>();
+            auto ri = std::make_unique<RoseInstrReportSomInt>();
             writeSomOperation(report, &ri->som);
             report_block.add_before_end(move(ri));
         }
         break;
     case INTERNAL_ROSE_CHAIN: {
-        report_block.add_before_end(make_unique<RoseInstrReportChain>(
+        report_block.add_before_end(std::make_unique<RoseInstrReportChain>(
             report.onmatch, report.topSquashDistance));
         break;
     }
@@ -663,17 +663,17 @@ void makeReport(const RoseBuildImpl &build, const ReportID id,
         makeDedupeSom(build.rm, report, report_block);
         if (report.ekey == INVALID_EKEY) {
             if (!report.quiet) {
-                report_block.add_before_end(make_unique<RoseInstrReportSom>(
+                report_block.add_before_end(std::make_unique<RoseInstrReportSom>(
                     report.onmatch, report.offsetAdjust));
             }
         } else {
             if (!report.quiet) {
                 report_block.add_before_end(
-                    make_unique<RoseInstrReportSomExhaust>(
+                    std::make_unique<RoseInstrReportSomExhaust>(
                         report.onmatch, report.offsetAdjust, report.ekey));
             } else {
                 report_block.add_before_end(
-                    make_unique<RoseInstrSetExhaust>(report.ekey));
+                    std::make_unique<RoseInstrSetExhaust>(report.ekey));
             }
         }
         addLogicalSetRequired(report, build.rm, report_block);
@@ -685,17 +685,17 @@ void makeReport(const RoseBuildImpl &build, const ReportID id,
         makeDedupeSom(build.rm, report, report_block);
         if (report.ekey == INVALID_EKEY) {
             if (!report.quiet) {
-                report_block.add_before_end(make_unique<RoseInstrReportSom>(
+                report_block.add_before_end(std::make_unique<RoseInstrReportSom>(
                     report.onmatch, report.offsetAdjust));
             }
         } else {
             if (!report.quiet) {
                 report_block.add_before_end(
-                    make_unique<RoseInstrReportSomExhaust>(
+                    std::make_unique<RoseInstrReportSomExhaust>(
                         report.onmatch, report.offsetAdjust, report.ekey));
             } else {
                 report_block.add_before_end(
-                    make_unique<RoseInstrSetExhaust>(report.ekey));
+                    std::make_unique<RoseInstrSetExhaust>(report.ekey));
             }
         }
         addLogicalSetRequired(report, build.rm, report_block);
@@ -722,11 +722,11 @@ void makeRoleReports(const RoseBuildImpl &build,
         assert(contains(leftfix_info, v));
         const left_build_info &lni = leftfix_info.at(v);
         program.add_before_end(
-            make_unique<RoseInstrSomLeftfix>(lni.queue, g[v].left.lag));
+            std::make_unique<RoseInstrSomLeftfix>(lni.queue, g[v].left.lag));
         report_som = true;
     } else if (g[v].som_adjust) {
         program.add_before_end(
-            make_unique<RoseInstrSomAdjust>(g[v].som_adjust));
+            std::make_unique<RoseInstrSomAdjust>(g[v].som_adjust));
         report_som = true;
     }
 
@@ -748,7 +748,7 @@ void makeRoleSetState(const unordered_map<RoseVertex, u32> &roleStateIndices,
     if (it == end(roleStateIndices)) {
         return;
     }
-    program.add_before_end(make_unique<RoseInstrSetState>(it->second));
+    program.add_before_end(std::make_unique<RoseInstrSetState>(it->second));
 }
 
 static
@@ -772,7 +772,7 @@ void makePushDelayedInstructions(const RoseLiteralMap &literals,
     });
 
     for (const auto &ri : delay_instructions) {
-        program.add_before_end(make_unique<RoseInstrPushDelayed>(ri));
+        program.add_before_end(std::make_unique<RoseInstrPushDelayed>(ri));
     }
 }
 
@@ -801,10 +801,10 @@ void makeCheckLiteralInstruction(const rose_literal_id &lit,
         const auto *end_inst = program.end_instruction();
         unique_ptr<RoseInstruction> ri;
         if (lit.s.any_nocase()) {
-            ri = make_unique<RoseInstrCheckMedLitNocase>(lit.s.get_string(),
+            ri = std::make_unique<RoseInstrCheckMedLitNocase>(lit.s.get_string(),
                                                          end_inst);
         } else {
-            ri = make_unique<RoseInstrCheckMedLit>(lit.s.get_string(),
+            ri = std::make_unique<RoseInstrCheckMedLit>(lit.s.get_string(),
                                                    end_inst);
         }
         program.add_before_end(move(ri));
@@ -820,10 +820,10 @@ void makeCheckLiteralInstruction(const rose_literal_id &lit,
     const auto *end_inst = program.end_instruction();
     unique_ptr<RoseInstruction> ri;
     if (lit.s.any_nocase()) {
-        ri = make_unique<RoseInstrCheckLongLitNocase>(lit.s.get_string(),
+        ri = std::make_unique<RoseInstrCheckLongLitNocase>(lit.s.get_string(),
                                                       end_inst);
     } else {
-        ri = make_unique<RoseInstrCheckLongLit>(lit.s.get_string(), end_inst);
+        ri = std::make_unique<RoseInstrCheckLongLit>(lit.s.get_string(), end_inst);
     }
     program.add_before_end(move(ri));
 }
@@ -840,7 +840,7 @@ void makeRoleCheckNotHandled(ProgramBuild &prog_build, RoseVertex v,
     }
 
     const auto *end_inst = program.end_instruction();
-    auto ri = make_unique<RoseInstrCheckNotHandled>(handled_key, end_inst);
+    auto ri = std::make_unique<RoseInstrCheckNotHandled>(handled_key, end_inst);
     program.add_before_end(move(ri));
 }
 
@@ -889,7 +889,7 @@ void makeRoleCheckBounds(const RoseBuildImpl &build, RoseVertex v,
 
     const auto *end_inst = program.end_instruction();
     program.add_before_end(
-        make_unique<RoseInstrCheckBounds>(min_bound, max_bound, end_inst));
+        std::make_unique<RoseInstrCheckBounds>(min_bound, max_bound, end_inst));
 }
 
 static
@@ -924,7 +924,7 @@ void makeRoleGroups(const RoseGraph &g, ProgramBuild &prog_build,
         return;
     }
 
-    program.add_before_end(make_unique<RoseInstrSetGroups>(groups));
+    program.add_before_end(std::make_unique<RoseInstrSetGroups>(groups));
 }
 
 static
@@ -968,7 +968,7 @@ bool makeRoleByte(const vector<LookEntry> &look, RoseProgram &program) {
         s32 checkbyte_offset = verify_s32(entry.offset);
         DEBUG_PRINTF("CHECK BYTE offset=%d\n", checkbyte_offset);
         const auto *end_inst = program.end_instruction();
-        auto ri = make_unique<RoseInstrCheckByte>(andmask_u8, cmpmask_u8, flip,
+        auto ri = std::make_unique<RoseInstrCheckByte>(andmask_u8, cmpmask_u8, flip,
                                                   checkbyte_offset, end_inst);
         program.add_before_end(move(ri));
         return true;
@@ -1000,7 +1000,7 @@ bool makeRoleMask(const vector<LookEntry> &look, RoseProgram &program) {
         DEBUG_PRINTF("CHECK MASK and_mask=%llx cmp_mask=%llx\n",
                      and_mask, cmp_mask);
         const auto *end_inst = program.end_instruction();
-        auto ri = make_unique<RoseInstrCheckMask>(and_mask, cmp_mask, neg_mask,
+        auto ri = std::make_unique<RoseInstrCheckMask>(and_mask, cmp_mask, neg_mask,
                                                   base_offset, end_inst);
         program.add_before_end(move(ri));
         return true;
@@ -1055,7 +1055,7 @@ bool makeRoleMask32(const vector<LookEntry> &look,
     DEBUG_PRINTF("base_offset %d\n", base_offset);
 
     const auto *end_inst = program.end_instruction();
-    auto ri = make_unique<RoseInstrCheckMask32>(and_mask, cmp_mask, neg_mask,
+    auto ri = std::make_unique<RoseInstrCheckMask32>(and_mask, cmp_mask, neg_mask,
                                                 base_offset, end_inst);
     program.add_before_end(move(ri));
     return true;
@@ -1098,7 +1098,7 @@ bool makeRoleMask64(const vector<LookEntry> &look,
     DEBUG_PRINTF("base_offset %d\n", base_offset);
 
     const auto *end_inst = program.end_instruction();
-    auto ri = make_unique<RoseInstrCheckMask64>(and_mask, cmp_mask, neg_mask,
+    auto ri = std::make_unique<RoseInstrCheckMask64>(and_mask, cmp_mask, neg_mask,
                                                 base_offset, end_inst);
     program.add_before_end(move(ri));
     return true;
@@ -1235,7 +1235,7 @@ makeCheckShufti16x8(u32 offset_range, u8 bucket_idx,
     copy(hi_mask.begin(), hi_mask.begin() + 16, nib_mask.begin() + 16);
     copy(bucket_select_mask.begin(), bucket_select_mask.begin() + 16,
          bucket_select_mask_16.begin());
-    return make_unique<RoseInstrCheckShufti16x8>
+    return std::make_unique<RoseInstrCheckShufti16x8>
            (nib_mask, bucket_select_mask_16,
             neg_mask & 0xffff, base_offset, end_inst);
 }
@@ -1255,7 +1255,7 @@ makeCheckShufti32x8(u32 offset_range, u8 bucket_idx,
     array<u8, 16> lo_mask_16;
     copy(hi_mask.begin(), hi_mask.begin() + 16, hi_mask_16.begin());
     copy(lo_mask.begin(), lo_mask.begin() + 16, lo_mask_16.begin());
-    return make_unique<RoseInstrCheckShufti32x8>
+    return std::make_unique<RoseInstrCheckShufti32x8>
            (hi_mask_16, lo_mask_16, bucket_select_mask,
             neg_mask, base_offset, end_inst);
 }
@@ -1277,7 +1277,7 @@ makeCheckShufti16x16(u32 offset_range, u8 bucket_idx,
          bucket_select_mask_32.begin());
     copy(bucket_select_mask_hi.begin(), bucket_select_mask_hi.begin() + 16,
          bucket_select_mask_32.begin() + 16);
-    return make_unique<RoseInstrCheckShufti16x16>
+    return std::make_unique<RoseInstrCheckShufti16x16>
            (hi_mask, lo_mask, bucket_select_mask_32,
             neg_mask & 0xffff, base_offset, end_inst);
 }
@@ -1294,7 +1294,7 @@ makeCheckShufti32x16(u32 offset_range, u8 bucket_idx,
         return nullptr;
     }
 
-    return make_unique<RoseInstrCheckShufti32x16>
+    return std::make_unique<RoseInstrCheckShufti32x16>
            (hi_mask, lo_mask, bucket_select_mask_hi,
             bucket_select_mask_lo, neg_mask, base_offset, end_inst);
 }
@@ -1321,7 +1321,7 @@ makeCheckShufti64x8(u32 offset_range, u8 bucket_idx,
     copy(lo_mask.begin(), lo_mask.begin() + 16, lo_mask_64.begin() + 32);
     copy(lo_mask.begin(), lo_mask.begin() + 16, lo_mask_64.begin() + 48);
 
-    return make_unique<RoseInstrCheckShufti64x8>
+    return std::make_unique<RoseInstrCheckShufti64x8>
            (hi_mask_64, lo_mask_64, bucket_select_mask,
             neg_mask, base_offset, end_inst);
 }
@@ -1361,7 +1361,7 @@ makeCheckShufti64x16(u32 offset_range, u8 bucket_idx,
     copy(lo_mask.begin() + 16, lo_mask.begin() + 32, lo_mask_2.begin() + 32);
     copy(lo_mask.begin() + 16, lo_mask.begin() + 32, lo_mask_2.begin() + 48);
 
-    return make_unique<RoseInstrCheckShufti64x16>
+    return std::make_unique<RoseInstrCheckShufti64x16>
            (hi_mask_1, hi_mask_2, lo_mask_1, lo_mask_2, bucket_select_mask_hi,
             bucket_select_mask_lo, neg_mask, base_offset, end_inst);
 }
@@ -1486,7 +1486,7 @@ void makeLookaroundInstruction(const vector<LookEntry> &look,
     if (look.size() == 1) {
         s8 offset = look.begin()->offset;
         const CharReach &reach = look.begin()->reach;
-        auto ri = make_unique<RoseInstrCheckSingleLookaround>(offset, reach,
+        auto ri = std::make_unique<RoseInstrCheckSingleLookaround>(offset, reach,
                                                      program.end_instruction());
         program.add_before_end(move(ri));
         return;
@@ -1508,7 +1508,7 @@ void makeLookaroundInstruction(const vector<LookEntry> &look,
         return;
     }
 
-    auto ri = make_unique<RoseInstrCheckLookaround>(look,
+    auto ri = std::make_unique<RoseInstrCheckLookaround>(look,
                                                     program.end_instruction());
     program.add_before_end(move(ri));
 }
@@ -1584,7 +1584,7 @@ void makeCheckLitEarlyInstruction(const RoseBuildImpl &build, u32 lit_id,
 
     DEBUG_PRINTF("adding lit early check, min_offset=%u\n", min_offset);
     const auto *end = prog.end_instruction();
-    prog.add_before_end(make_unique<RoseInstrCheckLitEarly>(min_offset, end));
+    prog.add_before_end(std::make_unique<RoseInstrCheckLitEarly>(min_offset, end));
 }
 
 static
@@ -1595,7 +1595,7 @@ void makeGroupCheckInstruction(const RoseBuildImpl &build, u32 lit_id,
     if (!info.group_mask) {
         return;
     }
-    prog.add_before_end(make_unique<RoseInstrCheckGroups>(info.group_mask));
+    prog.add_before_end(std::make_unique<RoseInstrCheckGroups>(info.group_mask));
 }
 
 static
@@ -1762,7 +1762,7 @@ bool makeRoleMultipathShufti(const vector<vector<LookEntry>> &multi_look,
         copy(begin(lo_mask), begin(lo_mask) + 16, nib_mask.begin());
         copy(begin(hi_mask), begin(hi_mask) + 16, nib_mask.begin() + 16);
 
-        auto ri = make_unique<RoseInstrCheckMultipathShufti16x8>
+        auto ri = std::make_unique<RoseInstrCheckMultipathShufti16x8>
                   (nib_mask, bucket_select_lo, data_select_mask, hi_bits_mask,
                    lo_bits_mask, neg_mask, base_offset, last_start, end_inst);
         program.add_before_end(move(ri));
@@ -1771,20 +1771,20 @@ bool makeRoleMultipathShufti(const vector<vector<LookEntry>> &multi_look,
         assert(!(hi_bits_mask & ~0xffffffffULL));
         assert(!(lo_bits_mask & ~0xffffffffULL));
         if (bit_index <= 8) {
-            auto ri = make_unique<RoseInstrCheckMultipathShufti32x8>
+            auto ri = std::make_unique<RoseInstrCheckMultipathShufti32x8>
                       (hi_mask, lo_mask, bucket_select_lo, data_select_mask,
                        hi_bits_mask, lo_bits_mask, neg_mask, base_offset,
                        last_start, end_inst);
             program.add_before_end(move(ri));
         } else {
-            auto ri = make_unique<RoseInstrCheckMultipathShufti32x16>
+            auto ri = std::make_unique<RoseInstrCheckMultipathShufti32x16>
                       (hi_mask, lo_mask, bucket_select_hi, bucket_select_lo,
                        data_select_mask, hi_bits_mask, lo_bits_mask, neg_mask,
                        base_offset, last_start, end_inst);
             program.add_before_end(move(ri));
         }
     } else {
-        auto ri = make_unique<RoseInstrCheckMultipathShufti64>
+        auto ri = std::make_unique<RoseInstrCheckMultipathShufti64>
                   (hi_mask, lo_mask, bucket_select_lo, data_select_mask,
                    hi_bits_mask, lo_bits_mask, neg_mask, base_offset,
                    last_start, end_inst);
@@ -1856,7 +1856,7 @@ void makeRoleMultipathLookaround(const vector<vector<LookEntry>> &multi_look,
         ordered_look.emplace_back(multi_entry);
     }
 
-    auto ri = make_unique<RoseInstrMultipathLookaround>(move(ordered_look),
+    auto ri = std::make_unique<RoseInstrMultipathLookaround>(move(ordered_look),
                                                         last_start, start_mask,
                                                     program.end_instruction());
     program.add_before_end(move(ri));
@@ -1932,7 +1932,7 @@ void makeRoleSuffix(const RoseBuildImpl &build,
         event = MQE_TOP;
     }
 
-    prog.add_before_end(make_unique<RoseInstrTriggerSuffix>(queue, event));
+    prog.add_before_end(std::make_unique<RoseInstrTriggerSuffix>(queue, event));
 }
 
 static
@@ -1945,7 +1945,7 @@ void addInfixTriggerInstructions(vector<TriggerInfo> triggers,
     });
     for (const auto &ti : triggers) {
         prog.add_before_end(
-             make_unique<RoseInstrTriggerInfix>(ti.cancel, ti.queue, ti.event));
+             std::make_unique<RoseInstrTriggerInfix>(ti.cancel, ti.queue, ti.event));
     }
 }
 
@@ -2039,7 +2039,7 @@ static
 void addCheckOnlyEodInstruction(RoseProgram &prog) {
     DEBUG_PRINTF("only at eod\n");
     const auto *end_inst = prog.end_instruction();
-    prog.add_before_end(make_unique<RoseInstrCheckOnlyEod>(end_inst));
+    prog.add_before_end(std::make_unique<RoseInstrCheckOnlyEod>(end_inst));
 }
 
 static
@@ -2164,7 +2164,7 @@ void makeGroupSquashInstruction(const RoseBuildImpl &build, u32 lit_id,
     DEBUG_PRINTF("squashes 0x%llx\n", info.group_mask);
     assert(info.group_mask);
     /* Note: group_mask is negated. */
-    prog.add_before_end(make_unique<RoseInstrSquashGroups>(~info.group_mask));
+    prog.add_before_end(std::make_unique<RoseInstrSquashGroups>(~info.group_mask));
 }
 
 namespace {
@@ -2209,7 +2209,7 @@ RoseProgram assembleProgramBlocks(vector<RoseProgram> &&blocks_in) {
          * only set if a state has been. */
         if (!prog.empty() && reads_work_done_flag(block)) {
             RoseProgram clear_block;
-            clear_block.add_before_end(make_unique<RoseInstrClearWorkDone>());
+            clear_block.add_before_end(std::make_unique<RoseInstrClearWorkDone>());
             prog.add_block(move(clear_block));
         }
 
@@ -2369,7 +2369,7 @@ void makeCatchupMpv(const ReportManager &rm, bool needs_mpv_catchup,
         return;
     }
 
-    program.add_before_end(make_unique<RoseInstrCatchUpMpv>());
+    program.add_before_end(std::make_unique<RoseInstrCatchUpMpv>());
 }
 
 RoseProgram makeReportProgram(const RoseBuildImpl &build,
@@ -2402,7 +2402,7 @@ RoseProgram makeBoundaryProgram(const RoseBuildImpl &build,
 void addIncludedJumpProgram(RoseProgram &program, u32 child_offset,
                             u8 squash) {
     RoseProgram block;
-    block.add_before_end(make_unique<RoseInstrIncludedJump>(child_offset,
+    block.add_before_end(std::make_unique<RoseInstrIncludedJump>(child_offset,
                                                             squash));
     program.add_block(move(block));
 }
@@ -2413,7 +2413,7 @@ void addPredBlockSingle(u32 pred_state, RoseProgram &pred_block,
     // Prepend an instruction to check the pred state is on.
     const auto *end_inst = pred_block.end_instruction();
     pred_block.insert(begin(pred_block),
-                      make_unique<RoseInstrCheckState>(pred_state, end_inst));
+                      std::make_unique<RoseInstrCheckState>(pred_state, end_inst));
     program.add_block(move(pred_block));
 }
 
@@ -2428,7 +2428,7 @@ void addPredBlocksAny(map<u32, RoseProgram> &pred_blocks, u32 num_states,
     }
 
     const RoseInstruction *end_inst = sparse_program.end_instruction();
-    auto ri = make_unique<RoseInstrSparseIterAny>(num_states, keys, end_inst);
+    auto ri = std::make_unique<RoseInstrSparseIterAny>(num_states, keys, end_inst);
     sparse_program.add_before_end(move(ri));
 
     RoseProgram &block = pred_blocks.begin()->second;
@@ -2451,14 +2451,14 @@ void addPredBlocksMulti(map<u32, RoseProgram> &pred_blocks,
     vector<pair<u32, const RoseInstruction *>> jump_table;
 
     // BEGIN instruction.
-    auto ri_begin = make_unique<RoseInstrSparseIterBegin>(num_states, end_inst);
+    auto ri_begin = std::make_unique<RoseInstrSparseIterBegin>(num_states, end_inst);
     RoseInstrSparseIterBegin *begin_inst = ri_begin.get();
     sparse_program.add_before_end(move(ri_begin));
 
     // NEXT instructions, one per pred program.
     u32 prev_key = pred_blocks.begin()->first;
     for (auto it = next(begin(pred_blocks)); it != end(pred_blocks); ++it) {
-        auto ri = make_unique<RoseInstrSparseIterNext>(prev_key, begin_inst,
+        auto ri = std::make_unique<RoseInstrSparseIterNext>(prev_key, begin_inst,
                                                        end_inst);
         sparse_program.add_before_end(move(ri));
         prev_key = it->first;
@@ -2539,7 +2539,7 @@ void applyFinalSpecialisation(RoseProgram &program) {
     auto it = next(program.rbegin());
     if (auto *ri = dynamic_cast<const RoseInstrReport *>(it->get())) {
         DEBUG_PRINTF("replacing REPORT with FINAL_REPORT\n");
-        program.replace(it, make_unique<RoseInstrFinalReport>(
+        program.replace(it, std::make_unique<RoseInstrFinalReport>(
                                 ri->onmatch, ri->offset_adjust));
     }
 }
